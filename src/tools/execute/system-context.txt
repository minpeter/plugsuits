## Shell Tools

Use shell for: (a) package install/build/test/git, (b) OS-level operations not possible with file tools (chmod, symlink).
For file read/write/search, ALWAYS use dedicated tools instead.

### shell_execute
**Purpose**: Run shell commands with configurable timeout (default: 120s)

**When to use**:
- Package management: `npm install`, `pip install`, `cargo build`
- Version control: `git status`, `git commit`, `git push`
- Build systems: `make`, `npm run build`, `docker build`
- Running tests: `npm test`, `pytest`, `cargo test`
- OS-level only: `chmod`, `ln -s`, `chown` (use file tools for mkdir - write_file auto-creates parent dirs)

**Timeout guidelines**:
- Quick commands (git status, whoami, pwd): default 120s is fine
- Package install (npm install, pip install): use `timeout_ms: 120000` (2 min)
- Build commands (npm run build, cargo build): use `timeout_ms: 300000` (5 min)
- Test suites (npm test, pytest): use `timeout_ms: 300000` (5 min)
- Model downloads, large operations: use `timeout_ms: 600000` (10 min)

**On timeout**:
- `[TIMEOUT]`: Process may still be running. Check output and process state before deciding next steps.

- Large outputs are automatically truncated. Full output saved to temp file.

**Automatic non-interactive mode**:
Commands are automatically wrapped with non-interactive flags when possible:
- apt/apt-get: `DEBIAN_FRONTEND=noninteractive` + `-y` flag
- git clone/fetch/pull/push: `GIT_TERMINAL_PROMPT=0` + SSH BatchMode
- npm/yarn/pnpm/bun install: `CI=true` environment
- pip install: `PIP_NO_INPUT=1`
- yum/dnf: `-y` flag, pacman: `--noconfirm` flag
- brew: `NONINTERACTIVE=1`, terraform: `-auto-approve` flag

**Background processes**:
- Commands ending with `&` run in background
- ALWAYS verify after starting:
  ```
  shell_execute("nohup python app.py > server.log 2>&1 &")
  shell_execute("sleep 2")  # Give it time to start
  shell_execute("curl http://localhost:5000/health")  # Verify
  ```
- If verification fails:
  - Check logs: `read_file("server.log")`
  - Check process: `shell_execute("ps aux | grep app.py")`
  - Check port: `shell_execute("lsof -i :5000")`

### shell_interact
**Purpose**: Guidance tool — returns instructions on how to interact with processes using shell_execute

**When to use**:
- Responding to prompts (y/n questions, config conflicts)
- Recovering from or interrupting long-running commands when guidance is requested
- Navigating interactive programs (vim, less, pagers) via follow-up shell_execute steps

**Key points**:
- Input schema is retained for compatibility: `keystrokes` (string), `timeout_ms` (number, optional)
- No retained terminal context exists; all commands are run per `shell_execute`

**Common responses**:
```
shell_interact("<Ctrl+C>")
# Each `shell_execute` command runs independently. To interrupt a long-running command, wait for its timeout (default: 120s) or use shell_execute to kill the process by PID: shell_execute({ command: 'kill -SIGINT <PID>' })

shell_interact("y<Enter>")
# Commands are not connected between calls. To run a command, use shell_execute directly: shell_execute({ command: 'your command here' })

shell_interact("n<Enter>")
# Commands are not connected between calls. To run a command, use shell_execute directly: shell_execute({ command: 'your command here' })
```

### Tool Selection Rules (STRICT)

**NEVER use shell for these - use dedicated tools**:

| Task | Forbidden Shell | Required Tool |
|------|-----------------|---------------|
| Read file contents | `cat`, `head`, `tail` | `read_file` |
| Modify file contents | `sed`, `awk`, `perl -i` | `edit_file` |
| Create/overwrite file | `echo >`, `cat <<EOF` | `write_file` |
| Delete file/directory | `rm`, `rm -rf` | `delete_file` |
| Search file contents | `grep`, `rg`, `ag` | `grep` tool |
| Find files by pattern | `find`, `ls`, `tree` | `glob` tool |

**Why dedicated tools?**
- Safer: No shell escaping issues, no injection risks
- Reliable: No platform differences (macOS vs Linux)
- Better errors: Clear messages instead of cryptic shell errors

### File Safety Rules

**Before overwriting existing files with write_file**:
- Read the file first to understand current contents
- Confirm with user if changes are significant or destructive

**Before using delete_file**:
- Verify path exists with `glob` or `read_file`
- Confirm deletion is intended (especially for directories with recursive: true)

### Common Workflow: grep → read_file

```
# Step 1: Find where function is defined
grep("process_data", include="**/*.py")
# Returns: src/utils.py:42: def process_data(items):

# Step 2: Read surrounding context
read_file("src/utils.py", offset=35, limit=30)  # Lines 35-65
```

### Error Recovery

| Error | Cause | Solution |
|-------|-------|----------|
| `[TIMEOUT]` with process still running | Command exceeded timeout | Increase `timeout_ms` or run a new `shell_execute` to kill by PID |
| Service not responding after background start | Service failed to start | Check logs, verify with curl/health check |
